#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Detailed Thai Sentiment Analysis System
р╕гр╕░р╕Ър╕Ъ sentiment analysis р╕ар╕▓р╕йр╕▓р╣Др╕Чр╕вр╣Бр╕Ър╕Ър╕ер╕░р╣Ар╕нр╕╡р╕вр╕Ф
р╕гр╕нр╕Зр╕гр╕▒р╕Ъ multi-class р╣Бр╕ер╕░ multi-label classification
"""

import json
import re
import random
from typing import List, Dict, Any, Optional, Union, Tuple
from datetime import datetime
from collections import defaultdict
import warnings
warnings.filterwarnings('ignore')

# === EMOTION LABEL SCHEMA ===
EMOTION_LABELS = [
    # Positive
    "р╕Фр╕╡р╣Гр╕И", "р╕Кр╕нр╕Ъ", "р╕Лр╕╢р╣Йр╕Зр╣Гр╕И", "р╕Юр╕нр╣Гр╕И", "р╕гр╕▒р╕Б",
    
    # Negative  
    "р╣Вр╕Бр╕гр╕Ш", "р╣Ар╕кр╕╡р╕вр╣Гр╕И", "р╕Ьр╕┤р╕Фр╕лр╕зр╕▒р╕З", "р╕гр╕│р╕Др╕▓р╕Н", "р╣Ар╕Бр╕ер╕╡р╕вр╕Ф", "р╕Бр╕ер╕▒р╕з", "р╕нр╕╢р╕Фр╕нр╕▒р╕Ф", "р╕Хр╕Бр╣Гр╕И",
    
    # Neutral
    "р╣Ар╕Йр╕в р╣Ж", "р╣Др╕бр╣Ир╕гр╕╣р╣Йр╕кр╕╢р╕Бр╕нр╕░р╣Др╕г", "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Вр╣Ир╕▓р╕зр╕кр╕▓р╕г",
    
    # Others (Complex emotions)
    "р╕Ыр╕гр╕░р╕Кр╕Ф", "р╕Вр╕│р╕Вр╕▒р╕Щ", "р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡", "р╕кр╕▒р╕Ър╕кр╕Щ"
]

# Emotion grouping
EMOTION_GROUPS = {
    "Positive": ["р╕Фр╕╡р╣Гр╕И", "р╕Кр╕нр╕Ъ", "р╕Лр╕╢р╣Йр╕Зр╣Гр╕И", "р╕Юр╕нр╣Гр╕И", "р╕гр╕▒р╕Б"],
    "Negative": ["р╣Вр╕Бр╕гр╕Ш", "р╣Ар╕кр╕╡р╕вр╣Гр╕И", "р╕Ьр╕┤р╕Фр╕лр╕зр╕▒р╕З", "р╕гр╕│р╕Др╕▓р╕Н", "р╣Ар╕Бр╕ер╕╡р╕вр╕Ф", "р╕Бр╕ер╕▒р╕з", "р╕нр╕╢р╕Фр╕нр╕▒р╕Ф", "р╕Хр╕Бр╣Гр╕И"],
    "Neutral": ["р╣Ар╕Йр╕в р╣Ж", "р╣Др╕бр╣Ир╕гр╕╣р╣Йр╕кр╕╢р╕Бр╕нр╕░р╣Др╕г", "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Вр╣Ир╕▓р╕зр╕кр╕▓р╕г"],
    "Others": ["р╕Ыр╕гр╕░р╕Кр╕Ф", "р╕Вр╕│р╕Вр╕▒р╕Щ", "р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡", "р╕кр╕▒р╕Ър╕кр╕Щ"]
}

# Reverse mapping for quick lookup
LABEL_TO_GROUP = {}
for group, labels in EMOTION_GROUPS.items():
    for label in labels:
        LABEL_TO_GROUP[label] = group

class ThaiEmotionPatterns:
    """р╕Др╕ер╕▓р╕к pattern matching р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕ар╕▓р╕йр╕▓р╣Др╕Чр╕в"""
    
    def __init__(self):
        self.emotion_patterns = self._build_emotion_patterns()
        self.intensity_patterns = self._build_intensity_patterns()
        self.context_patterns = self._build_context_patterns()
    
    def _build_emotion_patterns(self) -> Dict[str, Dict[str, Any]]:
        """р╕кр╕гр╣Йр╕▓р╕З patterns р╕кр╕│р╕лр╕гр╕▒р╕Ър╣Бр╕Хр╣Ир╕ер╕░р╕нр╕▓р╕гр╕бр╕Ур╣М"""
        return {
            # === POSITIVE EMOTIONS ===
            "р╕Фр╕╡р╣Гр╕И": {
                "keywords": ["р╕Фр╕╡р╣Гр╕И", "р╕бр╕╡р╕Др╕зр╕▓р╕бр╕кр╕╕р╕В", "р╣Бр╕ор╕Ыр╕Ыр╕╡р╣Й", "р╕Ыр╕ер╕╖р╣Йр╕б", "р╕вр╕┤р╕Щр╕Фр╕╡", "р╣Ар╕ор╕З", "р╣Ар╕вр╣Й", "р╣Вр╕вр╣И", "р╣Ар╕Ир╣Лр╕З", "р╕Фр╕╡р╣Ир╣Гр╕И"],
                "patterns": [r"р╕Фр╕╡\s*р╣Гр╕И", r"р╕Ыр╕ер╕╖р╣Йр╕б", r"р╣Ар╕ор╕З\s*р╕Лр╕░", r"р╣Бр╕ор╕Ыр╕Ыр╕╡р╣Й", r"р╣Ар╕вр╣Й.*", r"р╣Вр╕вр╣И.*"],
                "emojis": ["ЁЯШК", "ЁЯШД", "ЁЯдЧ", "ЁЯШН", "ЁЯе░", "ЁЯШШ", "ЁЯШЖ", "ЁЯдй"],
                "score_range": (0.6, 1.0)
            },
            
            "р╕Кр╕нр╕Ъ": {
                "keywords": ["р╕Кр╕нр╕Ъ", "р╕гр╕▒р╕Б", "р╕Цр╕╣р╕Бр╣Гр╕И", "р╣Вр╕Ыр╕гр╕Ф", "р╕Ыр╕ер╕╖р╣Йр╕б", "р╕кр╕Щр╣Гр╕И", "р╕нр╕┤р╕Щ", "р╣Ар╕Др╕ер╕┤р╣Йр╕б"],
                "patterns": [r"р╕Кр╕нр╕Ъ.*р╕бр╕▓р╕Б", r"р╕гр╕▒р╕Б.*р╣Ар╕ер╕в", r"р╕Цр╕╣р╕Бр╣Гр╕И", r"р╣Вр╕Ыр╕гр╕Ф.*", r"р╕кр╕Щр╣Гр╕И.*р╕бр╕▓р╕Б"],
                "emojis": ["тЭдя╕П", "ЁЯТХ", "ЁЯШН", "ЁЯе░", "ЁЯШШ", "ЁЯТЦ", "ЁЯТЭ"],
                "score_range": (0.5, 0.9)
            },
            
            "р╕Лр╕╢р╣Йр╕Зр╣Гр╕И": {
                "keywords": ["р╕Лр╕╢р╣Йр╕З", "р╕Лр╕╢р╣Йр╕Зр╣Гр╕И", "р╕Щр╣Йр╕│р╕Хр╕▓р╕Лр╕╢р╕б", "р╕Ыр╕гр╕░р╕Чр╕▒р╕Ър╣Гр╕И", "р╕Лр╕▓р╕Ър╕Лр╕╢р╣Йр╕З", "р╕Хр╕╖р╣Йр╕Щр╕Хр╕▒р╕Щ", "р╕Лр╕╖р╣Ир╕Щр╣Гр╕к"],
                "patterns": [r"р╕Лр╕╢р╣Йр╕З.*р╣Гр╕И", r"р╕Ыр╕гр╕░р╕Чр╕▒р╕Ър╣Гр╕И", r"р╕Щр╣Йр╕│р╕Хр╕▓.*р╕Лр╕╢р╕б", r"р╕Лр╕▓р╕Ър╕Лр╕╢р╣Йр╕З"],
                "emojis": ["ЁЯШн", "ЁЯе║", "ЁЯШв", "ЁЯдз", "ЁЯТЮ"],
                "score_range": (0.4, 0.8)
            },
            
            "р╕Юр╕нр╣Гр╕И": {
                "keywords": ["р╕Юр╕нр╣Гр╕И", "р╣Вр╕нр╣Ар╕Д", "р╣Гр╕Кр╣Йр╣Др╕Фр╣Й", "р╕Ыр╕Бр╕Хр╕┤р╕Фр╕╡", "р╣Др╕бр╣Ир╣Ар╕Ыр╣Зр╕Щр╣Др╕г", "р╕Зр╕▓р╕б", "р╣Ар╕гр╕╡р╕вр╕Ър╕гр╣Йр╕нр╕в"],
                "patterns": [r"р╕Юр╕нр╣Гр╕И", r"р╣Вр╕нр╣Ар╕Д.*", r"р╣Гр╕Кр╣Йр╣Др╕Фр╣Й", r"р╕Ыр╕Бр╕Хр╕┤р╕Фр╕╡", r"р╣Ар╕гр╕╡р╕вр╕Ър╕гр╣Йр╕нр╕в"],
                "emojis": ["ЁЯСН", "ЁЯСМ", "ЁЯШМ", "ЁЯЩВ"],
                "score_range": (0.2, 0.6)
            },
            
            "р╕гр╕▒р╕Б": {
                "keywords": ["р╕гр╕▒р╕Б", "р╕лр╕ер╕Зр╕гр╕▒р╕Б", "р╣Бр╕Юр╕З", "р╣Ар╕ер╕┤р╕Я", "love", "р╕ор╕▒р╕Бр╣Ж", "р╕ор╕▒р╕Б", "р╕гр╕▒р╕Бр╕бр╕▓р╕Б"],
                "patterns": [r"р╕гр╕▒р╕Б.*р╕бр╕▓р╕Б", r"р╕лр╕ер╕Зр╕гр╕▒р╕Б", r"р╣Ар╕ер╕┤р╕Я.*", r"love.*", r"р╕ор╕▒р╕Б.*"],
                "emojis": ["тЭдя╕П", "ЁЯТХ", "ЁЯТЦ", "ЁЯТЭ", "ЁЯШН", "ЁЯе░", "ЁЯШШ"],
                "score_range": (0.7, 1.0)
            },
            
            # === NEGATIVE EMOTIONS ===
            "р╣Вр╕Бр╕гр╕Ш": {
                "keywords": ["р╣Вр╕Бр╕гр╕Ш", "р╕Йр╕╕р╕Щ", "р╣Вр╕бр╣Вр╕л", "р╣Бр╕Др╣Йр╕Щ", "р╕Вр╕╕р╣Ир╕Щр╕Вр╣Йр╕нр╕З", "р╣Ар╕Фр╕╖р╕нр╕Ф", "р╕Ър╣Йр╕▓", "р╕лр╣Ир╕зр╕вр╣Бр╕Хр╕Б", "р╣Бр╕вр╣И", "р╕Зр╕╡р╣Ир╣Ар╕Зр╣Ир╕▓"],
                "patterns": [r"р╣Вр╕Бр╕гр╕Ш.*р╕бр╕▓р╕Б", r"р╕Йр╕╕р╕Щ.*р╕Вр╕▓р╕Ф", r"р╣Вр╕бр╣Вр╕л", r"р╣Бр╕Др╣Йр╕Щ.*", r"р╕лр╣Ир╕зр╕в.*р╣Бр╕Хр╕Б", r"р╕Ър╣Йр╕▓.*", r"р╣Бр╕вр╣И.*р╕бр╕▓р╕Б"],
                "emojis": ["ЁЯШа", "ЁЯШб", "ЁЯдм", "ЁЯС┐", "ЁЯТв", "ЁЯШд"],
                "score_range": (-1.0, -0.6)
            },
            
            "р╣Ар╕кр╕╡р╕вр╣Гр╕И": {
                "keywords": ["р╣Ар╕кр╕╡р╕вр╣Гр╕И", "р╣Ар╕ир╕гр╣Йр╕▓", "р╣Гр╕Ир╕лр╕▓р╕в", "р╕Ыр╕зр╕Фр╣Гр╕И", "р╣Ар╕ир╕гр╣Йр╕▓р╣Вр╕ир╕Б", "р╣Вр╕ир╕Бр╣Ар╕ир╕гр╣Йр╕▓", "р╣Ар╕кр╕╡р╕вр╕Фр╕▓р╕в", "р╕Щр╣Ир╕▓р╣Ар╕кр╕╡р╕вр╣Гр╕И"],
                "patterns": [r"р╣Ар╕кр╕╡р╕вр╣Гр╕И", r"р╣Ар╕ир╕гр╣Йр╕▓.*р╕бр╕▓р╕Б", r"р╣Гр╕Ир╕лр╕▓р╕в", r"р╕Ыр╕зр╕Фр╣Гр╕И", r"р╣Ар╕ир╕гр╣Йр╕▓р╣Вр╕ир╕Б"],
                "emojis": ["ЁЯШв", "ЁЯШн", "ЁЯШЮ", "тШ╣я╕П", "ЁЯШФ", "ЁЯТФ"],
                "score_range": (-0.8, -0.4)
            },
            
            "р╕Ьр╕┤р╕Фр╕лр╕зр╕▒р╕З": {
                "keywords": ["р╕Ьр╕┤р╕Фр╕лр╕зр╕▒р╕З", "р╕лр╕зр╕▒р╕Зр╣Ар╕Бр╕┤р╕Щ", "р╕Др╕▓р╕Фр╕лр╕зр╕▒р╕З", "р╕Чр╣Йр╕н", "р╕лр╕бр╕Фр╕лр╕зр╕▒р╕З", "р╣Др╕бр╣Ир╣Др╕Фр╣Йр╕Фр╕▒р╕Зр╣Гр╕И"],
                "patterns": [r"р╕Ьр╕┤р╕Фр╕лр╕зр╕▒р╕З", r"р╕лр╕зр╕▒р╕З.*р╣Ар╕Бр╕┤р╕Щ", r"р╕Др╕▓р╕Фр╕лр╕зр╕▒р╕З.*р╕бр╕▓р╕Б", r"р╕Чр╣Йр╕н.*", r"р╕лр╕бр╕Фр╕лр╕зр╕▒р╕З"],
                "emojis": ["ЁЯШЮ", "ЁЯШФ", "ЁЯШУ", "ЁЯШй", "ЁЯШд"],
                "score_range": (-0.7, -0.3)
            },
            
            "р╕гр╕│р╕Др╕▓р╕Н": {
                "keywords": ["р╕гр╕│р╕Др╕▓р╕Н", "р╕Щр╣Ир╕▓р╕гр╕│р╕Др╕▓р╕Н", "р╣Ар╕Ър╕╖р╣Ир╕н", "р╕лр╕Щр╣Ир╕▓р╕в", "р╣Ар╕Лр╣Зр╕З", "р╕Зр╣Ир╕зр╕З", "р╣Ар╕Др╕гр╕╡р╕вр╕Ф", "р╣Ар╕лр╕Щр╕╖р╣Ир╕нр╕в"],
                "patterns": [r"р╕гр╕│р╕Др╕▓р╕Н", r"р╣Ар╕Ър╕╖р╣Ир╕н.*р╕бр╕▓р╕Б", r"р╕лр╕Щр╣Ир╕▓р╕в.*", r"р╣Ар╕Лр╣Зр╕З.*", r"р╣Ар╕Др╕гр╕╡р╕вр╕Ф.*"],
                "emojis": ["ЁЯШТ", "ЁЯЩД", "ЁЯШд", "ЁЯШС", "ЁЯШл", "ЁЯШй"],
                "score_range": (-0.6, -0.2)
            },
            
            "р╣Ар╕Бр╕ер╕╡р╕вр╕Ф": {
                "keywords": ["р╣Ар╕Бр╕ер╕╡р╕вр╕Ф", "р╕Вр╕вр╕░р╣Бр╕Вр╕вр╕З", "р╣Бр╕Др╣Йр╕Щ", "р╣Бр╕Бр╕ер╣Йр╕З", "р╣Др╕бр╣Ир╕Кр╕нр╕Ъ", "р╕Хр╣Ир╕нр╕Хр╣Йр╕▓р╕Щ"],
                "patterns": [r"р╣Ар╕Бр╕ер╕╡р╕вр╕Ф.*р╕бр╕▓р╕Б", r"р╕Вр╕вр╕░р╣Бр╕Вр╕вр╕З", r"р╣Бр╕Др╣Йр╕Щ.*", r"р╣Др╕бр╣Ир╕Кр╕нр╕Ъ.*р╣Ар╕ер╕в"],
                "emojis": ["ЁЯШб", "ЁЯдм", "ЁЯС┐", "ЁЯШа", "ЁЯТв"],
                "score_range": (-1.0, -0.7)
            },
            
            "р╕Бр╕ер╕▒р╕з": {
                "keywords": ["р╕Бр╕ер╕▒р╕з", "р╕лр╕зр╕▓р╕Фр╕Бр╕ер╕▒р╕з", "р╕Хр╕Бр╣Гр╕И", "р╕зр╕┤р╕Хр╕Б", "р╕Бр╕▒р╕Зр╕зр╕е", "р╣Ар╕Др╕гр╕╡р╕вр╕Ф", "р╕лр╕зр╕▒р╣Ир╕Щ", "р╕Хр╕╖р╣Ир╕Щр╕Бр╕ер╕▒р╕з"],
                "patterns": [r"р╕Бр╕ер╕▒р╕з.*р╕бр╕▓р╕Б", r"р╕лр╕зр╕▓р╕Фр╕Бр╕ер╕▒р╕з", r"р╕Хр╕Бр╣Гр╕И.*", r"р╕зр╕┤р╕Хр╕Б.*", r"р╕Бр╕▒р╕Зр╕зр╕е.*"],
                "emojis": ["ЁЯШи", "ЁЯШ░", "ЁЯШ▒", "ЁЯШз", "ЁЯлг", "ЁЯШ│"],
                "score_range": (-0.8, -0.3)
            },
            
            "р╕нр╕╢р╕Фр╕нр╕▒р╕Ф": {
                "keywords": ["р╕нр╕╢р╕Фр╕нр╕▒р╕Ф", "р╕нр╕▒р╕Ър╕нр╕▓р╕в", "р╣Ар╕Бр╣Йр╕н", "р╣Др╕бр╣Ир╕кр╕Ър╕▓р╕вр╣Гр╕И", "р╕Бр╕Фр╕Фр╕▒р╕Щ", "р╕Вр╕▒р╕Фр╣Гр╕И"],
                "patterns": [r"р╕нр╕╢р╕Фр╕нр╕▒р╕Ф", r"р╕нр╕▒р╕Ър╕нр╕▓р╕в", r"р╣Др╕бр╣Ир╕кр╕Ър╕▓р╕вр╣Гр╕И", r"р╕Бр╕Фр╕Фр╕▒р╕Щ", r"р╕Вр╕▒р╕Фр╣Гр╕И"],
                "emojis": ["ЁЯШг", "ЁЯШЦ", "ЁЯШл", "ЁЯШд", "ЁЯШ░"],
                "score_range": (-0.6, -0.2)
            },
            
            "р╕Хр╕Бр╣Гр╕И": {
                "keywords": ["р╕Хр╕Бр╣Гр╕И", "р╕кр╕░р╕Фр╕╕р╣Йр╕З", "р╣Вр╕лр╕вр╕З", "р╕Хр╕Бр╕Хр╕░р╕ер╕╢р╕З", "р╕Хр╕░р╕ер╕╢р╕З", "р╕лр╕зр╕▓р╕Фр╣Ар╕кр╕╡р╕вр╕з"],
                "patterns": [r"р╕Хр╕Бр╣Гр╕И.*р╕бр╕▓р╕Б", r"р╕кр╕░р╕Фр╕╕р╣Йр╕З", r"р╣Вр╕лр╕вр╕З", r"р╕Хр╕Бр╕Хр╕░р╕ер╕╢р╕З", r"р╕Хр╕░р╕ер╕╢р╕З"],
                "emojis": ["ЁЯШ▒", "ЁЯШи", "ЁЯШ│", "ЁЯли", "ЁЯШз"],
                "score_range": (-0.5, 0.0)
            },
            
            # === NEUTRAL EMOTIONS ===
            "р╣Ар╕Йр╕в р╣Ж": {
                "keywords": ["р╣Ар╕Йр╕в", "р╕Шр╕гр╕гр╕бр╕Фр╕▓", "р╕Ыр╕Бр╕Хр╕┤", "р╣Вр╕нр╣Ар╕Д", "р╣Гр╕Кр╣Йр╣Др╕Фр╣Й", "р╕Юр╕нр╣Гр╕Кр╣Й", "р╣Др╕бр╣Ир╣Ар╕Ыр╣Зр╕Щр╣Др╕г"],
                "patterns": [r"р╣Ар╕Йр╕в.*р╣Ж", r"р╕Шр╕гр╕гр╕бр╕Фр╕▓", r"р╕Ыр╕Бр╕Хр╕┤.*", r"р╣Вр╕нр╣Ар╕Д", r"р╣Др╕бр╣Ир╣Ар╕Ыр╣Зр╕Щр╣Др╕г"],
                "emojis": ["ЁЯШР", "ЁЯЩВ", "ЁЯШ╢", "ЁЯШС"],
                "score_range": (-0.1, 0.1)
            },
            
            "р╣Др╕бр╣Ир╕гр╕╣р╣Йр╕кр╕╢р╕Бр╕нр╕░р╣Др╕г": {
                "keywords": ["р╣Др╕бр╣Ир╕гр╕╣р╣Йр╕кр╕╢р╕Б", "р╕Кр╕▓", "р╣Ар╕Йр╕в", "р╣Др╕бр╣Ир╕кр╕Щ", "р╣Др╕бр╣Ир╣Бр╕Др╕гр╣М", "р╣Др╕бр╣Ир╣Ар╕Вр╣Йр╕▓р╣Гр╕И"],
                "patterns": [r"р╣Др╕бр╣Ир╕гр╕╣р╣Йр╕кр╕╢р╕Б.*р╕нр╕░р╣Др╕г", r"р╕Кр╕▓.*", r"р╣Др╕бр╣Ир╕кр╕Щ.*", r"р╣Др╕бр╣Ир╣Бр╕Др╕гр╣М"],
                "emojis": ["ЁЯШ╢", "ЁЯШР", "ЁЯд╖тАНтЩАя╕П", "ЁЯд╖тАНтЩВя╕П"],
                "score_range": (-0.05, 0.05)
            },
            
            "р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Вр╣Ир╕▓р╕зр╕кр╕▓р╕г": {
                "keywords": ["р╕Вр╣Йр╕нр╕бр╕╣р╕е", "р╕Вр╣Ир╕▓р╕з", "р╕гр╕▓р╕вр╕Зр╕▓р╕Щ", "р╣Бр╕Ир╣Йр╕З", "р╕Ър╕нр╕Б", "р╕нр╕▒р╕Ыр╣Ар╕Фр╕Х", "р╕кр╕│р╕Др╕▒р╕Н"],
                "patterns": [r"р╕Вр╣Йр╕нр╕бр╕╣р╕е.*", r"р╕Вр╣Ир╕▓р╕з.*", r"р╕гр╕▓р╕вр╕Зр╕▓р╕Щ.*", r"р╣Бр╕Ир╣Йр╕З.*", r"р╕нр╕▒р╕Ыр╣Ар╕Фр╕Х.*"],
                "emojis": ["ЁЯУ░", "ЁЯУК", "ЁЯУИ", "ЁЯУв", "тД╣я╕П"],
                "score_range": (0.0, 0.0)
            },
            
            # === OTHERS (COMPLEX EMOTIONS) ===
            "р╕Ыр╕гр╕░р╕Кр╕Ф": {
                "keywords": ["р╕Ыр╕гр╕░р╕Кр╕Ф", "р╣Ар╕лр╕Щр╣Зр╕Ър╣Бр╕Щр╕б", "р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡", "р╣Бр╕Фр╕Бр╕Фр╕▒р╕Щ", "р╕Ир╕┤р╕Бр╕Бр╕▒р╕Ф", "р╕нр╕╡р╕Фр╕нр╕Б"],
                "patterns": [r"р╕Ыр╕гр╕░р╕Кр╕Ф.*", r"р╣Ар╕лр╕Щр╣Зр╕Ър╣Бр╕Щр╕б", r"р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡.*", r"р╣Бр╕Фр╕Бр╕Фр╕▒р╕Щ", r"р╕Ир╕┤р╕Бр╕Бр╕▒р╕Ф"],
                "emojis": ["ЁЯШП", "ЁЯЩД", "ЁЯШТ", "ЁЯШд"],
                "score_range": (-0.4, -0.1)
            },
            
            "р╕Вр╕│р╕Вр╕▒р╕Щ": {
                "keywords": ["р╕Вр╕│", "р╕Хр╕ер╕Б", "555", "р╕ор╕▓", "р╣Ар╕ор╕ор╕▓", "р╕кр╕Щр╕╕р╕Б", "р╣Вр╕ер╕Бр╣Бр╕Хр╕Б", "р╕Др╕гр╕╖р╣Ир╕Щр╣Ар╕Др╕гр╕З"],
                "patterns": [r"р╕Вр╕│.*", r"р╕Хр╕ер╕Б.*", r"555+", r"р╕ор╕▓+", r"р╣Ар╕ор╕ор╕▓", r"р╕кр╕Щр╕╕р╕Б.*"],
                "emojis": ["ЁЯШВ", "ЁЯдг", "ЁЯШЖ", "ЁЯШД", "ЁЯШБ", "ЁЯдк", "ЁЯШЬ"],
                "score_range": (0.3, 0.8)
            },
            
            "р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡": {
                "keywords": ["р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡", "р╕Ыр╕гр╕░р╕Кр╕Ф", "р╣Ар╕лр╕Щр╣Зр╕Ъ", "р╣Бр╕Щр╕б", "р╕Ир╕┤р╕Бр╕Бр╕▒р╕Ф", "р╣Бр╕Бр╕ер╣Йр╕З"],
                "patterns": [r"р╣Ар╕кр╕╡р╕вр╕Фр╕кр╕╡.*", r"р╕Ыр╕гр╕░р╕Кр╕Ф.*", r"р╣Ар╕лр╕Щр╣Зр╕Ъ.*р╣Бр╕Щр╕б", r"р╕Ир╕┤р╕Бр╕Бр╕▒р╕Ф.*"],
                "emojis": ["ЁЯШП", "ЁЯЩД", "ЁЯШТ"],
                "score_range": (-0.5, -0.2)
            },
            
            "р╕кр╕▒р╕Ър╕кр╕Щ": {
                "keywords": ["р╕кр╕▒р╕Ър╕кр╕Щ", "р╕Зр╕З", "р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╣Др╕бр╣Ир╣Др╕Фр╣Й", "р╣Бр╕Ыр╕ер╕Б", "р╕Йр╕Зр╕Щ", "р╕Йр╕Зр╕Щр╕кр╕Щр╣Ар╕Чр╣Ир╕лр╣М"],
                "patterns": [r"р╕кр╕▒р╕Ър╕кр╕Щ", r"р╕Зр╕З.*", r"р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╣Др╕бр╣Ир╣Др╕Фр╣Й", r"р╣Бр╕Ыр╕ер╕Б.*", r"р╕Йр╕Зр╕Щ.*"],
                "emojis": ["ЁЯШХ", "ЁЯдФ", "ЁЯШ╡тАНЁЯТл", "ЁЯлд", "ЁЯШ╡"],
                "score_range": (-0.2, 0.2)
            }
        }
    
    def _build_intensity_patterns(self) -> Dict[str, List[str]]:
        """р╕кр╕гр╣Йр╕▓р╕З patterns р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Др╕зр╕▓р╕бр╣Ар╕Вр╣Йр╕бр╕Вр╣Йр╕Щр╕Вр╕нр╕Зр╕нр╕▓р╕гр╕бр╕Ур╣М"""
        return {
            "high": ["р╕бр╕▓р╕Б", "р╣Ар╕ер╕в", "р╕кр╕╕р╕Ф", "р╣Бр╕гр╕З", "р╕лр╕Щр╕▒р╕Б", "р╣Вр╕Др╕Хр╕г", "р╣Бр╕кр╕Щ", "р╕кр╕▓р╕лр╕▒р╕к", "р╣Ар╕Ыр╣Зр╕Щр╕Ър╣Йр╕▓", "р╕Ир╕гр╕┤р╕Зр╣Ж"],
            "medium": ["р╕Юр╕н", "р╕Др╣Ир╕нр╕Щр╕Вр╣Йр╕▓р╕З", "р╕Ыр╕▓р╕Щр╕Бр╕ер╕▓р╕З", "р╣Гр╕Кр╣Йр╣Др╕Фр╣Й", "р╣Вр╕нр╣Ар╕Д"],
            "low": ["р╣Ар╕ер╣Зр╕Бр╕Щр╣Йр╕нр╕в", "р╕Щр╕┤р╕Фр╕лр╕Щр╣Ир╕нр╕в", "р╣Ар╕Ър╕▓р╣Ж", "р╕Щр╕┤р╕Фр╣Ар╕Фр╕╡р╕вр╕з", "р╣Др╕бр╣Ир╕бр╕▓р╕Б"]
        }
    
    def _build_context_patterns(self) -> Dict[str, List[str]]:
        """р╕кр╕гр╣Йр╕▓р╕З patterns р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Ър╕гр╕┤р╕Ър╕Чр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕ар╕▓р╕йр╕▓"""
        return {
            "formal": ["р╕Др╕гр╕▒р╕Ъ", "р╕Др╣Ир╕░", "р╕Др╕░", "р╕Вр╕н", "р╕Бр╕гр╕╕р╕Ур╕▓", "р╕кр╕зр╕▒р╕кр╕Фр╕╡", "р╕Вр╕нр╕Ър╕Др╕╕р╕У"],
            "informal": ["р╕Щр╕░", "р╣Ар╕Щр╕нр╕░", "р╕нр╕░", "р╣Ар╕нр╣Йр╕в", "р╣Ар╕нр╕н", "р╕Вр╕нр╕З", "555", "р╕ор╕▓"],
            "slang": ["р╣Вр╕Др╕Хр╕г", "р╣Ар╕Яр╕╡р╣Йр╕вр╕з", "р╣Ар╕Чр╕Ю", "р╣Бр╕бр╣Ир╕З", "р╕Др╕зр╕в", "р╕Ър╕┤р╕Щ", "р╣Ар╕Яр╕╡р╣Йр╕вр╕б"],
            "personal": ["р╕Бр╕╣", "р╕бр╕╢р╕З", "р╣Ар╕гр╕▓", "р╕Йр╕▒р╕Щ", "р╕Др╕┤р╕Ф", "р╕гр╕╣р╣Йр╕кр╕╢р╕Б"]
        }

class DetailedThaiSentimentAnalyzer:
    """р╕гр╕░р╕Ър╕Ър╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М sentiment р╕ар╕▓р╕йр╕▓р╣Др╕Чр╕вр╣Бр╕Ър╕Ър╕ер╕░р╣Ар╕нр╕╡р╕вр╕Ф"""
    
    def __init__(self):
        self.patterns = ThaiEmotionPatterns()
        self.multi_label_threshold = 0.3  # threshold р╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕гр╕Хр╕▒р╕Фр╕кр╕┤р╕Щ multi-label
        
    def _clean_text(self, text: str) -> str:
        """р╕Чр╕│р╕Др╕зр╕▓р╕бр╕кр╕░р╕нр╕▓р╕Фр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б"""
        if not text:
            return ""
        
        # р╣Бр╕Ыр╕ер╕Зр╣Ар╕Ыр╣Зр╕Щр╕Хр╕▒р╕зр╕Юр╕┤р╕бр╕Юр╣Мр╣Ар╕ер╣Зр╕Б
        text = text.lower()
        
        # р╕ер╕Ъ URL
        text = re.sub(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', '', text)
        
        # р╕ер╕Ъ mentions р╣Бр╕ер╕░ hashtags р╣Гр╕Щ social media
        text = re.sub(r'[@#]\w+', '', text)
        
        # р╕Чр╕│р╕Др╕зр╕▓р╕бр╕кр╕░р╕нр╕▓р╕Фр╕Кр╣Ир╕нр╕Зр╕зр╣Ир╕▓р╕Зр╣Ар╕Бр╕┤р╕Щ
        text = re.sub(r'\s+', ' ', text).strip()
        
        return text
    
    def _extract_emojis(self, text: str) -> List[str]:
        """р╕Фр╕╢р╕З emojis р╕Ир╕▓р╕Бр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б"""
        emoji_pattern = re.compile(
            "["
            "\U0001F600-\U0001F64F"  # emoticons
            "\U0001F300-\U0001F5FF"  # symbols & pictographs
            "\U0001F680-\U0001F6FF"  # transport & map
            "\U0001F1E0-\U0001F1FF"  # flags
            "\U00002702-\U000027B0"
            "\U000024C2-\U0001F251"
            "]+", flags=re.UNICODE
        )
        return emoji_pattern.findall(text)
    
    def _calculate_emotion_scores(self, text: str) -> Dict[str, float]:
        """р╕Др╕│р╕Щр╕зр╕Ур╕Др╕░р╣Бр╕Щр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Бр╕Хр╣Ир╕ер╕░р╕нр╕▓р╕гр╕бр╕Ур╣М"""
        clean_text = self._clean_text(text)
        emojis = self._extract_emojis(text)
        emotion_scores = defaultdict(float)
        
        for emotion, config in self.patterns.emotion_patterns.items():
            score = 0.0
            
            # р╕Др╕░р╣Бр╕Щр╕Щр╕Ир╕▓р╕Бр╕Др╕│р╕кр╕│р╕Др╕▒р╕Н
            for keyword in config["keywords"]:
                if keyword in clean_text:
                    score += 1.0
            
            # р╕Др╕░р╣Бр╕Щр╕Щр╕Ир╕▓р╕Б patterns (regex)
            for pattern in config.get("patterns", []):
                matches = re.findall(pattern, clean_text)
                score += len(matches) * 1.5
            
            # р╕Др╕░р╣Бр╕Щр╕Щр╕Ир╕▓р╕Б emojis
            for emoji in emojis:
                if emoji in config.get("emojis", []):
                    score += 2.0
            
            # р╕Ыр╕гр╕▒р╕Ър╕Др╕░р╣Бр╕Щр╕Щр╕Хр╕▓р╕бр╕Др╕зр╕▓р╕бр╣Ар╕Вр╣Йр╕бр╕Вр╣Йр╕Щ
            intensity_bonus = self._calculate_intensity_bonus(clean_text)
            score *= (1 + intensity_bonus)
            
            emotion_scores[emotion] = min(score, 5.0)  # р╕Ир╕│р╕Бр╕▒р╕Фр╕Др╕░р╣Бр╕Щр╕Щр╕кр╕╣р╕Зр╕кр╕╕р╕Ф
        
        return dict(emotion_scores)
    
    def _calculate_intensity_bonus(self, text: str) -> float:
        """р╕Др╕│р╕Щр╕зр╕У bonus р╕Ир╕▓р╕Бр╕Др╕зр╕▓р╕бр╣Ар╕Вр╣Йр╕бр╕Вр╣Йр╕Щр╕Вр╕нр╕Зр╕Бр╕▓р╕гр╣Бр╕кр╕Фр╕Зр╕нр╕нр╕Б"""
        bonus = 0.0
        
        for intensity, words in self.patterns.intensity_patterns.items():
            for word in words:
                if word in text:
                    if intensity == "high":
                        bonus += 0.5
                    elif intensity == "medium":
                        bonus += 0.2
                    elif intensity == "low":
                        bonus += 0.1
        
        return min(bonus, 1.0)  # р╕Ир╕│р╕Бр╕▒р╕Ф bonus р╕кр╕╣р╕Зр╕кр╕╕р╕Ф
    
    def _determine_context(self, text: str) -> str:
        """р╕Бр╕│р╕лр╕Щр╕Фр╕Ър╕гр╕┤р╕Ър╕Чр╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕ар╕▓р╕йр╕▓"""
        clean_text = self._clean_text(text)
        context_scores = defaultdict(int)
        
        for context, words in self.patterns.context_patterns.items():
            for word in words:
                if word in clean_text:
                    context_scores[context] += 1
        
        if not context_scores:
            return "neutral"
        
        return max(context_scores, key=context_scores.get)
    
    def _normalize_scores(self, scores: Dict[str, float]) -> Dict[str, float]:
        """normalize р╕Др╕░р╣Бр╕Щр╕Щр╣Гр╕лр╣Йр╕нр╕вр╕╣р╣Ир╣Гр╕Щр╕Кр╣Ир╕зр╕З 0-1"""
        if not scores:
            return {}
        
        max_score = max(scores.values())
        if max_score == 0:
            return scores
        
        return {emotion: score / max_score for emotion, score in scores.items()}
    
    def analyze_single_label(self, text: str) -> Dict[str, Any]:
        """р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М sentiment р╣Бр╕Ър╕Ъ single label (multi-class classification)"""
        if not text or not text.strip():
            return {
                "text": text,
                "label": "р╣Ар╕Йр╕в р╣Ж",
                "group": "Neutral",
                "confidence": 0.0,
                "scores": {},
                "context": "neutral",
                "analysis_type": "single_label"
            }
        
        # р╕Др╕│р╕Щр╕зр╕Ур╕Др╕░р╣Бр╕Щр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Бр╕Хр╣Ир╕ер╕░р╕нр╕▓р╕гр╕бр╕Ур╣М
        raw_scores = self._calculate_emotion_scores(text)
        normalized_scores = self._normalize_scores(raw_scores)
        
        # р╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╕бр╕╡р╕Др╕░р╣Бр╕Щр╕Щр╕кр╕╣р╕Зр╕кр╕╕р╕Ф
        if not normalized_scores:
            predicted_label = "р╣Ар╕Йр╕в р╣Ж"
            confidence = 0.0
        else:
            predicted_label = max(normalized_scores, key=normalized_scores.get)
            confidence = normalized_scores[predicted_label]
        
        # р╕Бр╕│р╕лр╕Щр╕Фр╕Бр╕ер╕╕р╣Ир╕бр╕нр╕▓р╕гр╕бр╕Ур╣М
        group = LABEL_TO_GROUP.get(predicted_label, "Unknown")
        
        # р╕Бр╕│р╕лр╕Щр╕Фр╕Ър╕гр╕┤р╕Ър╕Ч
        context = self._determine_context(text)
        
        return {
            "text": text,
            "label": predicted_label,
            "group": group,
            "confidence": round(confidence, 3),
            "scores": {k: round(v, 3) for k, v in normalized_scores.items()},
            "context": context,
            "analysis_type": "single_label",
            "timestamp": datetime.now().isoformat()
        }
    
    def analyze_multi_label(self, text: str, threshold: float = None) -> Dict[str, Any]:
        """р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М sentiment р╣Бр╕Ър╕Ъ multi-label classification"""
        if threshold is None:
            threshold = self.multi_label_threshold
        
        if not text or not text.strip():
            return {
                "text": text,
                "labels": ["р╣Ар╕Йр╕в р╣Ж"],
                "groups": ["Neutral"],
                "scores": {},
                "context": "neutral",
                "analysis_type": "multi_label",
                "threshold": threshold
            }
        
        # р╕Др╕│р╕Щр╕зр╕Ур╕Др╕░р╣Бр╕Щр╕Щр╕кр╕│р╕лр╕гр╕▒р╕Ър╣Бр╕Хр╣Ир╕ер╕░р╕нр╕▓р╕гр╕бр╕Ур╣М
        raw_scores = self._calculate_emotion_scores(text)
        normalized_scores = self._normalize_scores(raw_scores)
        
        # р╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╕бр╕╡р╕Др╕░р╣Бр╕Щр╕Щр╣Ар╕Бр╕┤р╕Щ threshold
        predicted_labels = []
        for emotion, score in normalized_scores.items():
            if score >= threshold:
                predicted_labels.append(emotion)
        
        # р╕Цр╣Йр╕▓р╣Др╕бр╣Ир╕бр╕╡р╕нр╕▓р╕гр╕бр╕Ур╣Мр╣Гр╕Фр╣Ар╕Бр╕┤р╕Щ threshold р╣Гр╕лр╣Йр╣Ар╕ер╕╖р╕нр╕Бр╕Хр╕▒р╕зр╕Чр╕╡р╣Ир╕кр╕╣р╕Зр╕кр╕╕р╕Ф
        if not predicted_labels and normalized_scores:
            predicted_labels = [max(normalized_scores, key=normalized_scores.get)]
        elif not predicted_labels:
            predicted_labels = ["р╣Ар╕Йр╕в р╣Ж"]
        
        # р╕Бр╕│р╕лр╕Щр╕Фр╕Бр╕ер╕╕р╣Ир╕бр╕нр╕▓р╕гр╕бр╕Ур╣М
        groups = list(set(LABEL_TO_GROUP.get(label, "Unknown") for label in predicted_labels))
        
        # р╕Бр╕│р╕лр╕Щр╕Фр╕Ър╕гр╕┤р╕Ър╕Ч
        context = self._determine_context(text)
        
        return {
            "text": text,
            "labels": predicted_labels,
            "groups": groups,
            "scores": {k: round(v, 3) for k, v in normalized_scores.items()},
            "context": context,
            "analysis_type": "multi_label",
            "threshold": threshold,
            "timestamp": datetime.now().isoformat()
        }
    
    def analyze_batch(self, texts: List[str], multi_label: bool = False, threshold: float = None) -> List[Dict[str, Any]]:
        """р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М sentiment р╣Бр╕Ър╕Ъ batch"""
        results = []
        
        for text in texts:
            if multi_label:
                result = self.analyze_multi_label(text, threshold)
            else:
                result = self.analyze_single_label(text)
            
            results.append(result)
        
        return results
    
    def get_emotion_statistics(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """р╕Др╕│р╕Щр╕зр╕Ур╕кр╕Цр╕┤р╕Хр╕┤р╕Вр╕нр╕Зр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Ир╕▓р╕Бр╕Ьр╕ер╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М"""
        if not results:
            return {}
        
        stats = {
            "total_texts": len(results),
            "analysis_type": results[0].get("analysis_type", "unknown"),
            "emotion_counts": defaultdict(int),
            "group_counts": defaultdict(int),
            "context_counts": defaultdict(int),
            "avg_confidence": 0.0
        }
        
        total_confidence = 0.0
        
        for result in results:
            # р╕Щр╕▒р╕Ър╕нр╕▓р╕гр╕бр╕Ур╣М
            if "label" in result:  # single label
                stats["emotion_counts"][result["label"]] += 1
                stats["group_counts"][result["group"]] += 1
                total_confidence += result.get("confidence", 0.0)
            elif "labels" in result:  # multi label
                for label in result["labels"]:
                    stats["emotion_counts"][label] += 1
                for group in result["groups"]:
                    stats["group_counts"][group] += 1
                # р╕кр╕│р╕лр╕гр╕▒р╕Ъ multi-label р╣Гр╕Кр╣Йр╕Др╕░р╣Бр╕Щр╕Щр╕кр╕╣р╕Зр╕кр╕╕р╕Фр╣Ар╕Ыр╣Зр╕Щ confidence
                if result["scores"]:
                    total_confidence += max(result["scores"].values())
            
            # р╕Щр╕▒р╕Ър╕Ър╕гр╕┤р╕Ър╕Ч
            context = result.get("context", "unknown")
            stats["context_counts"][context] += 1
        
        # р╕Др╕│р╕Щр╕зр╕У confidence р╣Ар╕Йр╕ер╕╡р╣Ир╕в
        if stats["total_texts"] > 0:
            stats["avg_confidence"] = round(total_confidence / stats["total_texts"], 3)
        
        # р╣Бр╕Ыр╕ер╕Зр╕Ир╕▓р╕Б defaultdict р╣Ар╕Ыр╣Зр╕Щ dict р╕Шр╕гр╕гр╕бр╕Фр╕▓
        stats["emotion_counts"] = dict(stats["emotion_counts"])
        stats["group_counts"] = dict(stats["group_counts"])
        stats["context_counts"] = dict(stats["context_counts"])
        
        return stats

# === UTILITY FUNCTIONS ===

def create_training_data_format(
    text: str, 
    labels: Union[str, List[str]], 
    format_type: str = "classification"
) -> Dict[str, Any]:
    """р╕кр╕гр╣Йр╕▓р╕Зр╕гр╕╣р╕Ыр╣Бр╕Ър╕Ър╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╕лр╕гр╕▒р╕Ър╕Бр╕▓р╕г train model"""
    
    if format_type == "classification":
        # р╕кр╕│р╕лр╕гр╕▒р╕Ъ traditional ML models (BERT, RoBERTa, etc.)
        if isinstance(labels, str):
            return {
                "text": text,
                "label": labels,
                "label_id": EMOTION_LABELS.index(labels) if labels in EMOTION_LABELS else 0
            }
        else:
            # Multi-label: р╕кр╕гр╣Йр╕▓р╕З binary vector
            label_vector = [0] * len(EMOTION_LABELS)
            for label in labels:
                if label in EMOTION_LABELS:
                    label_vector[EMOTION_LABELS.index(label)] = 1
            
            return {
                "text": text,
                "labels": labels,
                "label_vector": label_vector
            }
    
    elif format_type == "instruction":
        # р╕кр╕│р╕лр╕гр╕▒р╕Ъ LLM fine-tuning
        if isinstance(labels, str):
            instruction = "р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Щр╕╡р╣Йр╣Бр╕ер╕░р╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕бр╕Чр╕╡р╣Ир╕кр╕╕р╕Ф"
            output = labels
        else:
            instruction = "р╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣Мр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Вр╕нр╕Зр╕Вр╣Йр╕нр╕Др╕зр╕▓р╕бр╕Щр╕╡р╣Йр╣Бр╕ер╕░р╣Ар╕ер╕╖р╕нр╕Бр╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╣Ар╕лр╕бр╕▓р╕░р╕кр╕б (р╕кр╕▓р╕бр╕▓р╕гр╕Цр╣Ар╕ер╕╖р╕нр╕Бр╣Др╕Фр╣Йр╕лр╕ер╕▓р╕вр╕нр╕▓р╕гр╕бр╕Ур╣М)"
            output = ", ".join(labels)
        
        return {
            "instruction": instruction,
            "input": text,
            "output": output
        }
    
    else:
        raise ValueError(f"Unsupported format_type: {format_type}")

def save_training_data(
    data: List[Dict[str, Any]], 
    output_path: str, 
    format_type: str = "jsonl"
) -> str:
    """р╕Ър╕▒р╕Щр╕Чр╕╢р╕Бр╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Бр╕▓р╕г train"""
    
    if format_type == "jsonl":
        with open(output_path, 'w', encoding='utf-8') as f:
            for item in data:
                f.write(json.dumps(item, ensure_ascii=False) + '\n')
    
    elif format_type == "json":
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    else:
        raise ValueError(f"Unsupported format_type: {format_type}")
    
    return output_path

def demo_detailed_sentiment_analysis():
    """Demo р╕Бр╕▓р╕гр╣Гр╕Кр╣Йр╕Зр╕▓р╕Щр╕гр╕░р╕Ър╕Ъ sentiment analysis р╣Бр╕Ър╕Ър╕ер╕░р╣Ар╕нр╕╡р╕вр╕Ф"""
    
    print("ЁЯОп Demo: Detailed Thai Sentiment Analysis")
    print("=" * 60)
    
    # р╕кр╕гр╣Йр╕▓р╕З analyzer
    analyzer = DetailedThaiSentimentAnalyzer()
    
    # р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕Чр╕Фр╕кр╕нр╕Ъ
    test_texts = [
        "р╣Вр╕Бр╕гр╕Шр╕Ир╕Щр╕Вр╕│р╕нр╕░р╕Кр╕╡р╕зр╕┤р╕Х! р╕Чр╕│р╣Др╕бр╕Хр╣Йр╕нр╕Зр╕бр╕▓р╣Бр╕Ър╕Ър╕Щр╕╡р╣Йр╕Фр╣Йр╕зр╕в 555",
        "р╕Ыр╕гр╕░р╕Кр╕Фр╕лр╕Щр╕▒р╕Бр╕бр╕▓р╕Бр╕Ир╕Щр╕гр╕╣р╣Йр╕кр╕╢р╕Бр╣Бр╕вр╣И р╣Ар╕Ыр╣Зр╕Щр╣Бр╕Ър╕Ър╕Щр╕╡р╣Йр╕Чр╕╕р╕Бр╕Чр╕╡р╣Ар╕ер╕в",
        "р╕бр╕▒р╕Щр╕Бр╣Зр╣Вр╕нр╣Ар╕Д р╣Бр╕Хр╣Ир╣Др╕бр╣Ир╕кр╕╕р╕Ф р╕Др╕▓р╕Фр╕лр╕зр╕▒р╕Зр╣Др╕зр╣Йр╕бр╕▓р╕Бр╕Бр╕зр╣Ир╕▓р╕Щр╕╡р╣Й",
        "р╕Фр╕╡р╣Гр╕Ир╕бр╕▓р╕Бр╣Ар╕ер╕в! р╕гр╕▒р╕Бр╕бр╕▓р╕Бр╣Ж р╕Вр╕нр╕Ър╕Др╕╕р╕Ур╕Щр╕░р╕Др╕░ ЁЯШНтЭдя╕П",
        "р╕лр╣Ир╕зр╕вр╣Бр╕Хр╕Бр╣Бр╕ер╣Йр╕зр╕Ир╕гр╕┤р╕Зр╣Ж р╣Вр╕Чр╕гр╣Др╕Ыр╣Бр╕Ир╣Йр╕Зр╕Бр╣Зр╣Др╕бр╣Ир╣Бр╕Бр╣Йр╣Др╕В р╕Вр╣Йр╕нр╕бр╕╣р╕ер╕кр╕│р╕Др╕▒р╕Нр╕Щр╕╡р╣Й",
        "р╕Зр╕Зр╕бр╕▓р╕Бр╣Ар╕ер╕в р╕кр╕▒р╕Ър╕кр╕Щр╕Ир╕гр╕┤р╕Зр╣Ж р╣Ар╕Вр╣Йр╕▓р╣Гр╕Ир╣Др╕бр╣Ир╣Др╕Фр╣Й ЁЯдФ",
        "р╕Вр╣Ир╕▓р╕зр╕кр╕▓р╕гр╕нр╕▒р╕Ыр╣Ар╕Фр╕Хр╕Ыр╕гр╕░р╕Ир╕│р╕зр╕▒р╕Щ р╕кр╕Цр╕▓р╕Щр╕Бр╕▓р╕гр╕Ур╣Мр╕Ыр╕Бр╕Хр╕┤р╕Фр╕╡"
    ]
    
    print("\nЁЯУН Single Label Analysis (Multi-class Classification)")
    print("-" * 50)
    
    single_results = []
    for text in test_texts:
        result = analyzer.analyze_single_label(text)
        single_results.append(result)
        
        print(f"р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б: {text}")
        print(f"р╕нр╕▓р╕гр╕бр╕Ур╣М: {result['label']} (р╕Бр╕ер╕╕р╣Ир╕б: {result['group']})")
        print(f"р╕Др╕зр╕▓р╕бр╕бр╕▒р╣Ир╕Щр╣Гр╕И: {result['confidence']}")
        print(f"р╕Ър╕гр╕┤р╕Ър╕Ч: {result['context']}")
        print(f"р╕Др╕░р╣Бр╕Щр╕Щр╕нр╕╖р╣Ир╕Щр╣Ж: {result['scores']}")
        print("-" * 30)
    
    print("\nЁЯУН Multi-Label Analysis (Multi-label Classification)")
    print("-" * 50)
    
    multi_results = []
    for text in test_texts:
        result = analyzer.analyze_multi_label(text, threshold=0.3)
        multi_results.append(result)
        
        print(f"р╕Вр╣Йр╕нр╕Др╕зр╕▓р╕б: {text}")
        print(f"р╕нр╕▓р╕гр╕бр╕Ур╣М: {result['labels']} (р╕Бр╕ер╕╕р╣Ир╕б: {result['groups']})")
        print(f"р╕Ър╕гр╕┤р╕Ър╕Ч: {result['context']}")
        print(f"р╕Др╕░р╣Бр╕Щр╕Щр╕Чр╕▒р╣Йр╕Зр╕лр╕бр╕Ф: {result['scores']}")
        print("-" * 30)
    
    # р╣Бр╕кр╕Фр╕Зр╕кр╕Цр╕┤р╕Хр╕┤
    print("\nЁЯУК р╕кр╕Цр╕┤р╕Хр╕┤р╕Бр╕▓р╕гр╕зр╕┤р╣Ар╕Др╕гр╕▓р╕░р╕лр╣М")
    print("-" * 50)
    
    single_stats = analyzer.get_emotion_statistics(single_results)
    multi_stats = analyzer.get_emotion_statistics(multi_results)
    
    print("Single Label:")
    print(f"  - р╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╕Юр╕Ъ: {single_stats['emotion_counts']}")
    print(f"  - р╕Бр╕ер╕╕р╣Ир╕бр╕нр╕▓р╕гр╕бр╕Ур╣М: {single_stats['group_counts']}")
    print(f"  - р╕Др╕зр╕▓р╕бр╕бр╕▒р╣Ир╕Щр╣Гр╕Ир╣Ар╕Йр╕ер╕╡р╣Ир╕в: {single_stats['avg_confidence']}")
    
    print("\nMulti Label:")
    print(f"  - р╕нр╕▓р╕гр╕бр╕Ур╣Мр╕Чр╕╡р╣Ир╕Юр╕Ъ: {multi_stats['emotion_counts']}")
    print(f"  - р╕Бр╕ер╕╕р╣Ир╕бр╕нр╕▓р╕гр╕бр╕Ур╣М: {multi_stats['group_counts']}")
    print(f"  - р╕Др╕зр╕▓р╕бр╕бр╕▒р╣Ир╕Щр╣Гр╕Ир╣Ар╕Йр╕ер╕╡р╣Ир╕в: {multi_stats['avg_confidence']}")
    
    print("\nЁЯУЭ р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Бр╕▓р╕гр╕кр╕гр╣Йр╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е Training")
    print("-" * 50)
    
    # р╕кр╕гр╣Йр╕▓р╕Зр╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕Зр╕Вр╣Йр╕нр╕бр╕╣р╕е training
    training_examples = []
    
    # Single label examples
    training_examples.append(
        create_training_data_format("р╣Вр╕Бр╕гр╕Шр╕Ир╕Щр╕Вр╕│р╕нр╕░р╕Кр╕╡р╕зр╕┤р╕Х!", "р╣Вр╕Бр╕гр╕Ш", "classification")
    )
    
    # Multi-label examples
    training_examples.append(
        create_training_data_format("р╣Вр╕Бр╕гр╕Шр╕Ир╕Щр╕Вр╕│р╕нр╕░р╕Кр╕╡р╕зр╕┤р╕Х!", ["р╣Вр╕Бр╕гр╕Ш", "р╕Вр╕│р╕Вр╕▒р╕Щ"], "classification")
    )
    
    # Instruction format for LLM
    training_examples.append(
        create_training_data_format("р╕Ыр╕гр╕░р╕Кр╕Фр╕лр╕Щр╕▒р╕Бр╕бр╕▓р╕Бр╕Ир╕Щр╕гр╕╣р╣Йр╕кр╕╢р╕Бр╣Бр╕вр╣И", ["р╕Ыр╕гр╕░р╕Кр╕Ф", "р╣Ар╕кр╕╡р╕вр╣Гр╕И"], "instruction")
    )
    
    for i, example in enumerate(training_examples):
        print(f"р╕Хр╕▒р╕зр╕нр╕вр╣Ир╕▓р╕З {i+1}:")
        print(json.dumps(example, ensure_ascii=False, indent=2))
        print()

if __name__ == "__main__":
    demo_detailed_sentiment_analysis()
